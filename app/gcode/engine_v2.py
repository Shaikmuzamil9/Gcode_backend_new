import os
import uuid
import math
from typing import Tuple

import cv2
import numpy as np
from PIL import Image


def _ensure_gcode_dir(image_path: str) -> str:
    gcode_dir = os.path.join(os.path.dirname(image_path), "..", "gcodes")
    gcode_dir = os.path.abspath(gcode_dir)
    os.makedirs(gcode_dir, exist_ok=True)
    return gcode_dir


def generate_vector_gcode(image_path: str, pixel_to_mm: float = 0.1) -> str:
    """
    Vector engraving (outline) using Canny + contours.
    - image_path: disk path to source image
    - pixel_to_mm: how many millimeters per pixel
    Returns disk path to generated G-code file
    """
    if not os.path.exists(image_path):
        raise FileNotFoundError("Image not found")

    img = cv2.imread(image_path)
    if img is None:
        raise ValueError("Unable to read image")

    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    # Use Canny edge detector
    edges = cv2.Canny(gray, 50, 150)

    # Find contours
    contours, _ = cv2.findContours(edges, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)

    gcode_dir = _ensure_gcode_dir(image_path)
    gcode_filename = f"{uuid.uuid4()}_vector.gcode"
    gcode_path = os.path.join(gcode_dir, gcode_filename)

    # Write simple G-code: G21 mm, G90 abs, lift Z between contours
    with open(gcode_path, "w", encoding="utf-8") as f:
        f.write("(Vector engraving generated by engine_v2)\n")
        f.write("G21\n")
        f.write("G90\n")
        f.write("G0 Z5 F3000\n")

        for cnt in contours:
            if len(cnt) < 2:
                continue

            # Move to first point
            x0, y0 = cnt[0][0]
            x_mm = x0 * pixel_to_mm
            y_mm = y0 * pixel_to_mm
            f.write(f"G0 X{round(x_mm,3)} Y{round(y_mm,3)} F6000\n")
            # Lower to engraving Z
            f.write("G1 Z0 F1000\n")

            # Trace contour
            for pt in cnt[1:]:
                x, y = pt[0]
                f.write(f"G1 X{round(x*pixel_to_mm,3)} Y{round(y*pixel_to_mm,3)} F1500\n")

            # Lift
            f.write("G0 Z5 F3000\n")

        f.write("M5\n")

    return gcode_path


def _map_brightness_to_power(bright: int, min_power: int = 0, max_power: int = 255) -> int:
    # Inverse mapping: darker pixel -> higher power (for engraving)
    return int((255 - bright) / 255.0 * (max_power - min_power) + min_power)


def generate_raster_gcode(image_path: str, pixel_size_mm: float = 0.1, max_width_mm: float = 100.0,
                          feed_rate: int = 1200) -> str:
    """
    Raster engraving (photo) - scans image row-by-row and emits G-code with laser power (M3 Sxxx)
    - pixel_size_mm: physical size per pixel
    - max_width_mm: limit working area width; image will be resized to fit
    """
    if not os.path.exists(image_path):
        raise FileNotFoundError("Image not found")

    pil = Image.open(image_path).convert("L")

    # Resize to fit max_width_mm
    width_px = pil.width
    height_px = pil.height
    current_width_mm = width_px * pixel_size_mm
    if current_width_mm > max_width_mm:
        scale = max_width_mm / current_width_mm
        new_w = max(1, int(width_px * scale))
        new_h = max(1, int(height_px * scale))
        pil = pil.resize((new_w, new_h), Image.LANCZOS)

    img = np.array(pil)
    h, w = img.shape

    gcode_dir = _ensure_gcode_dir(image_path)
    gcode_filename = f"{uuid.uuid4()}_raster.gcode"
    gcode_path = os.path.join(gcode_dir, gcode_filename)

    with open(gcode_path, "w", encoding="utf-8") as f:
        f.write("(Raster engraving generated by engine_v2)\n")
        f.write("G21\n")
        f.write("G90\n")
        f.write("G0 Z5 F3000\n")

        # Start at top-left
        for row in range(h):
            y_mm = row * pixel_size_mm
            # Move to start of line
            f.write(f"G0 X0 Y{round(y_mm,3)} F6000\n")
            f.write("G1 Z0 F1000\n")

            # For raster we will emit S value with M3
            line_pixels = img[row]

            # For efficiency, group continuous segments with non-zero power
            in_segment = False
            for col in range(w):
                bright = int(line_pixels[col])
                power = _map_brightness_to_power(bright)
                x_mm = col * pixel_size_mm

                if power <= 0:
                    # No power: lift or keep laser off
                    if in_segment:
                        f.write("M5\n")
                        in_segment = False
                    # move without engraving
                    f.write(f"G0 X{round(x_mm,3)} Y{round(y_mm,3)} F6000\n")
                else:
                    if not in_segment:
                        # Start laser with power
                        f.write(f"M3 S{power}\n")
                        in_segment = True
                    # Engrave to position
                    f.write(f"G1 X{round(x_mm,3)} Y{round(y_mm,3)} S{power} F{feed_rate}\n")

            if in_segment:
                f.write("M5\n")
                in_segment = False

            # Lift between lines
            f.write("G0 Z5 F3000\n")

        f.write("M5\n")

    return gcode_path
